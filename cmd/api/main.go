package main

import (
	"database/sql"
	"net/http"
	"os"
	"time"

	_ "github.com/lib/pq"

	"multitrackticketing/config"
	_ "multitrackticketing/docs" // This will be generated by swag init
	"multitrackticketing/internal/adapters/auth"
	"multitrackticketing/internal/adapters/email"
	"multitrackticketing/internal/adapters/sessionize"
	httpDelivery "multitrackticketing/internal/delivery/http"
	"multitrackticketing/internal/delivery/http/controllers"
	"multitrackticketing/internal/delivery/http/middleware"
	"multitrackticketing/internal/repository/postgres"
	"multitrackticketing/internal/services"
)

// @title Multi-Track Ticketing API
// @version 1.0
// @description This is the backend API for a conference ticketing system.
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() {
	logger := config.NewLogger()

	// 1. Configuration
	cfg, err := config.Load(logger)
	if err != nil {
		logger.Error("failed to load config", "err", err)
		os.Exit(1)
	}

	// 2. Database Connection
	db, err := sql.Open("postgres", cfg.DBUrl)
	if err != nil {
		logger.Error("failed to open database", "err", err)
		os.Exit(1)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		logger.Error("could not connect to database", "err", err)
		os.Exit(1)
	}
	logger.Info("connected to database")

	// 3. Init Layers
	eventRepo := postgres.NewEventRepository(db)
	sessionRepo := postgres.NewSessionRepository(db)
	eventTeamMemberRepo := postgres.NewEventTeamMemberRepository(db)
	eventInvitationRepo := postgres.NewEventInvitationRepository(db)
	eventRegistrationRepo := postgres.NewEventRegistrationRepository(db)
	userRepo := postgres.NewUserRepository(db)
	roleRepo := postgres.NewRoleRepository(db)
	loginCodeRepo := postgres.NewLoginCodeRepository(db)
	sessionizeFetcher := sessionize.NewHTTPFetcher(nil)

	mailerCfg := email.MailerConfig{
		Provider:    cfg.Email.Provider,
		FromAddress: cfg.Email.FromAddress,
		FromName:    cfg.Email.FromName,
		SES: email.SESConfig{
			Region:             cfg.Email.SES.Region,
			AccessKeyID:        cfg.Email.SES.AccessKeyID,
			SecretAccessKey:    cfg.Email.SES.SecretAccessKey,
			InsecureSkipVerify: cfg.Email.SES.InsecureSkipVerify,
		},
	}
	mailer, err := email.NewMailer(mailerCfg)
	if err != nil {
		logger.Error("failed to create mailer", "err", err)
		os.Exit(1)
	}
	templateRenderer := email.NewTemplateRenderer()
	emailService := services.NewEmailService(mailer, templateRenderer)

	manageScheduleService := services.NewEventService(eventRepo, sessionRepo, eventTeamMemberRepo, userRepo, eventInvitationRepo, emailService, sessionizeFetcher, 10*time.Second)
	scheduleController := controllers.NewScheduleController(logger, manageScheduleService)
	attendeeService := services.NewAttendeeService(eventRepo, eventRegistrationRepo)
	attendeeController := controllers.NewAttendeeController(logger, attendeeService)

	jwtSecret := cfg.JWTSecret
	if jwtSecret == "" {
		if cfg.Environment == "production" {
			logger.Error("JWT_SECRET is required in production")
			os.Exit(1)
		}
		jwtSecret = "dev-secret-change-in-production"
	}
	jwtAuth := auth.NewJWTIssuer(jwtSecret, cfg.JWTExpiry)

	userService := services.NewUserService(userRepo, roleRepo, loginCodeRepo, jwtAuth, cfg.JWTExpiry, emailService)
	userController := controllers.NewUserController(logger, userService)
	requireAuth := middleware.RequireAuth(jwtAuth, logger)

	// 4. Router
	mux := httpDelivery.NewRouter(scheduleController, userController, attendeeController, requireAuth)
	handler := middleware.CORS(cfg.CORSOrigins, middleware.LoggingMiddleware(logger, mux))

	// 5. Server
	port := ":" + cfg.Port
	logger.Info("server starting", "port", port)
	if err := http.ListenAndServe(port, handler); err != nil {
		logger.Error("server failed", "err", err)
		os.Exit(1)
	}
}
