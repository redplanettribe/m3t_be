---
description: Go test conventions â€” table-driven tests, testify, httptest, sqlmock, fakes
globs: "**/*_test.go"
alwaysApply: false
---

# Testing

- **Table-driven tests**: Use a slice of cases and `for _, tt := range cases { t.Run(tt.name, func(t *testing.T) { ... }) }`. Include at least `name` and input/expected (or setup and assertions) per case.
- **Assertions**: Use **testify** (`require` and `assert`). Prefer `require` for setup or when failure should stop the test; use `assert` for checks. Do not use ad-hoc `if x != y { t.Fatal(...) }` for comparisons. For errors: `require.NoError(t, err)`, `assert.Error(t, err)`, and optionally `errors.Is`/`errors.As` for wrapped errors.
- **Handlers**: Use `httptest.NewRequest` and `httptest.ResponseRecorder`. Inject a fake or mock implementing the service interface (e.g. `domain.EventService`); no real service or DB. Assert on response status and body (e.g. decode JSON or check substring).
- **Service**: Inject fake repositories (in-memory or stubs implementing `domain.EventRepository`/`domain.SessionRepository`). For code that calls external HTTP (e.g. Sessionize), isolate via an injected client or a small fetcher interface so unit tests do not hit the network.
- **Repositories**: Use **go-sqlmock** for unit tests: create mock DB, set `ExpectQuery`/`ExpectExec`/`ExpectQueryRow` and their results, call the repo method, then `require.NoError(t, mock.ExpectationsWereMet())` and assert return values. Integration tests against a real DB (if added) use `//go:build integration` and are run with `go test -tags=integration ./...`.
- **Placement**: Put tests next to the code under test (`*_test.go` in the same package). Run with `go test ./...` from the repo root (or `make test`); use `make test-cover` for coverage. Follow [go-conventions.mdc](go-conventions.mdc) for production code style; in tests, keep assertions clear and consistent.
